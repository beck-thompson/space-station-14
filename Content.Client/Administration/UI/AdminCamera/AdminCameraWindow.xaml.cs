using Content.Client.Eye;
using Content.Shared.Administration;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.Timing;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Timing;

namespace Content.Client.Administration.UI.AdminCamera;

[GenerateTypedNameReferences]
public sealed partial class AdminCameraWindow : DefaultWindow
{
    [Dependency] private readonly IEntityManager _entManager = default!;
    [Dependency] private readonly IClientGameTiming _timing = default!;
    public event Action? OnFollow;
    public event Action? OnPopout;

    private readonly EyeLerpingSystem _eyeLerpingSystem;
    private readonly FixedEye _defaultEye = new();
    private AdminCameraEuiState? _nextState;

    public EntityUid? CurrentCamera;

    public AdminCameraWindow()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        _eyeLerpingSystem = _entManager.System<EyeLerpingSystem>();

        CameraView.ViewportSize = new Vector2i(400, 400);
        CameraView.Eye = _defaultEye;

        FollowButton.OnPressed += _ => OnFollow?.Invoke();
        PopoutButton.OnPressed += _ =>
        {
            OnPopout?.Invoke();
            WindowHeader.Visible = false;
        };
    }

    public void SetState(AdminCameraEuiState state)
    {
        _nextState = state;
    }

    // I know that this is awful, but I copied this from the solution editor anyways.
    // This is needed because EUIs update before the gamestate is applied, which means it will fail to get the uid from the net entity.
    // The suggestion from the comment in the solution editor saying to use a BUI is even worse:
    // - BUIs have range checks hardcoded in, which can only be bypassed by having GhostComponent or IgnoreUIRangeComponent.
    // - Both of these would bypass *any* BUI range checks.
    // - The UI would close if we ghost or otherwise leave the body.
    // - If we spawn a dummy entity for the BUI and parent it to the user we have the same problem when changing bodies.
    // I am choosing the lesser evil.
    protected override void FrameUpdate(FrameEventArgs args)
    {
        if (_nextState == null || _timing.LastRealTick < _nextState.Tick) // make sure the last gamestate has been applied
            return;

        if (!_entManager.TryGetEntity(_nextState.Camera, out var cameraUid))
            return;

        if (CurrentCamera == null)
        {
            _eyeLerpingSystem.AddEye(cameraUid.Value);
            CurrentCamera = cameraUid;
        }
        else if (CurrentCamera != cameraUid)
        {
            _eyeLerpingSystem.RemoveEye(CurrentCamera.Value);
            _eyeLerpingSystem.AddEye(cameraUid.Value);
            CurrentCamera = cameraUid;
        }

        if (_entManager.TryGetComponent<EyeComponent>(CurrentCamera, out var eye))
        {
            CameraView.Eye = eye.Eye ?? _defaultEye;
            Title = Loc.GetString("admin-camera-window-title", ("name", _nextState.Name));
        }
    }
}
